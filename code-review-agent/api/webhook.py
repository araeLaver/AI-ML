"""GitHub webhook handler for automated PR reviews."""
import hashlib
import hmac
import os
from typing import Any

from fastapi import APIRouter, Request, HTTPException, BackgroundTasks
from pydantic import BaseModel

router = APIRouter(prefix="/webhook", tags=["webhook"])


class WebhookPayload(BaseModel):
    """GitHub webhook payload model."""
    action: str
    number: int | None = None
    pull_request: dict | None = None
    repository: dict | None = None


def verify_signature(payload: bytes, signature: str, secret: str) -> bool:
    """Verify GitHub webhook signature.

    Args:
        payload: Raw request body
        signature: X-Hub-Signature-256 header
        secret: Webhook secret

    Returns:
        True if signature is valid
    """
    if not signature:
        return False

    expected = "sha256=" + hmac.new(
        secret.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(expected, signature)


async def process_pr_review(repo_name: str, pr_number: int) -> None:
    """Background task to process PR review.

    Args:
        repo_name: Repository name (owner/repo)
        pr_number: Pull request number
    """
    from langchain_openai import ChatOpenAI
    from tools.github_tools import GitHubTools
    from workflows.review_workflow import run_review

    # Initialize
    llm = ChatOpenAI(model="gpt-4o", temperature=0)
    github = GitHubTools()

    # Fetch PR data
    pr_data = github.get_pr_data(repo_name, pr_number)

    # Review each file
    all_reviews = []
    for file in pr_data.files:
        if file.content and file.status != "removed":
            result = run_review(llm, file.content, {
                "file_path": file.filename,
                "language": "auto"
            })
            all_reviews.append({
                "file": file.filename,
                "report": result.get("final_report", "")
            })

    # Post combined review
    combined_report = format_combined_report(pr_data, all_reviews)
    github.post_review_comment(repo_name, pr_number, combined_report)


def format_combined_report(pr_data: Any, reviews: list[dict]) -> str:
    """Format all file reviews into a single PR comment."""
    report = f"""## ðŸ¤– AI Code Review

**PR:** #{pr_data.number} - {pr_data.title}
**Files reviewed:** {len(reviews)}

---

"""
    for review in reviews:
        report += f"### ðŸ“„ `{review['file']}`\n\n"
        report += review["report"]
        report += "\n\n---\n\n"

    report += "\n\n*Generated by Code Review Agent*"
    return report


@router.post("/github")
async def handle_github_webhook(
    request: Request,
    background_tasks: BackgroundTasks
) -> dict:
    """Handle incoming GitHub webhooks.

    Triggers automated PR review on PR open/synchronize events.
    """
    # Verify signature
    secret = os.getenv("GITHUB_WEBHOOK_SECRET", "")
    signature = request.headers.get("X-Hub-Signature-256", "")
    body = await request.body()

    if secret and not verify_signature(body, signature, secret):
        raise HTTPException(status_code=401, detail="Invalid signature")

    # Parse payload
    payload = await request.json()
    event = request.headers.get("X-GitHub-Event", "")

    # Handle PR events
    if event == "pull_request":
        action = payload.get("action")
        if action in ("opened", "synchronize", "reopened"):
            pr = payload.get("pull_request", {})
            repo = payload.get("repository", {})

            repo_name = repo.get("full_name")
            pr_number = pr.get("number")

            if repo_name and pr_number:
                background_tasks.add_task(
                    process_pr_review,
                    repo_name,
                    pr_number
                )
                return {
                    "status": "processing",
                    "message": f"Review queued for PR #{pr_number}"
                }

    return {"status": "ignored", "event": event}
